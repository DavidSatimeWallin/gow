package main

import (
	"crypto/aes"
	"crypto/cipher"
	"encoding/base64"
	"encoding/json"
	"flag"
	"fmt"
	"html/template"
	"log"
	"net/http"
	"os"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/google/uuid"
	"github.com/gorilla/mux"
	"github.com/gorilla/sessions"
	"github.com/kennygrant/sanitize"
	"github.com/microcosm-cc/bluemonday"
	scribble "github.com/nanobox-io/golang-scribble"
	"github.com/patrickmn/go-cache"
	"github.com/renstrom/fuzzysearch/fuzzy"
	"github.com/russross/blackfriday"
)

type (
	config struct {
		Host            string
		Port            string
		Bucket          string
		Key             string
		User            string
		Pwd             string
		NumerOfArticles int
	}
	article struct {
		Link    string
		Title   string
		Content []byte
		Created string
		PTL     int
	}
	articlesDescending     []article
	articlesDateDescending []article
)

func (v articlesDescending) Len() int           { return len(v) }
func (v articlesDescending) Swap(i, j int)      { v[i], v[j] = v[j], v[i] }
func (a articlesDescending) Less(i, j int) bool { return a[i].Title > a[j].Title }

func (v articlesDateDescending) Len() int           { return len(v) }
func (v articlesDateDescending) Swap(i, j int)      { v[i], v[j] = v[j], v[i] }
func (a articlesDateDescending) Less(i, j int) bool { return a[i].Created > a[j].Created }

var (
	Cfg        config
	DB         *scribble.Driver
	commonIV   []byte
	c          cipher.Block
	err        error
	store      = sessions.NewCookieStore([]byte(Cfg.Key))
	gowUUID    = uuid.New().String()
	GOW_TITLE  = "LIB.BZ"
	GOW_HEADER = "<!DOCTYPE html><html><head><title>" + GOW_TITLE + "</title><style> * { color:#2c3e50; font-family:'Lucida Sans Unicode', 'Lucida Grande', sans-serif; }a { color:#3498db; text-decoration:none; font-weight:bold; }nav ul { list-style-type:none; padding:0; }nav ul li { display:inline; margin:0 10px; }article { margin: 0 0 25px 0; border-left: 10px solid #e67e22; padding: 10px;}article h2 {text-transform: uppercase; }#pagination { list-style-type:none; padding:0; }#pagination li { display:inline; margin:0 10px; border: 1px solid #dedede; color: #3f3f3f; font: 13.3333px Arial; padding: 5px 12px; }.big { color: #ccc; text-transform: uppercase; font-weight: 100;font-size:35px; margin: 35px 0 55px 10px;}.go-back-link {display:inline-block;}.go-back-link a {background-color:#EEEEEE;padding:5px 12px;font-weight:500;font: 13.3333px Arial;color:#3F3F3F;border:1px solid #dedede;}</style></head><body><header style='border-bottom:1px solid #EEEEEE;height:30px;padding-top:10px;'><div style='margin: 0 10px;'><a href='/'>" + GOW_TITLE + "</a></div></header><nav><ul>%s<li><a href='/list'>List articles</a></li><li><a href='/search'>Search articles</a></li></ul></nav><div style='padding: 10px 0;'><div style='margin: 0 10px;'>"
	GOW_FOOTER = "</div></div></body></html>"
	Cache      = cache.New(5*time.Minute, 20*time.Minute)
)

func init() {
	flag.StringVar(&Cfg.Host, "host", "0.0.0.0", "the host on which to host the web interface")
	flag.StringVar(&Cfg.Port, "port", "9090", "the port you want to run GOW on")
	flag.StringVar(&Cfg.Bucket, "bucket", "./gow.bucket", "the folder in which data should be stored")
	flag.StringVar(&Cfg.Key, "key", "d51b2bf666420e87ab91d08ef07f2e08", "the secret key you want to use for encryption")
	flag.StringVar(&Cfg.User, "user", "", "the name of the admin user")
	flag.StringVar(&Cfg.Pwd, "pwd", "", "the password for the admin user")
	flag.IntVar(&Cfg.NumerOfArticles, "numberOfArticles", 10, "How many articles to show on frontpage")
	flag.Parse()
	keyLength := len(Cfg.Key)
	if keyLength != 32 {
		fmt.Println("The security key must be 32 characters long")
		if keyLength > 32 {
			fmt.Printf("You gave %d too many characters\n", (keyLength - 32))
		}
		if keyLength < 32 {
			fmt.Printf("You gave %d too few characters\n", (32 - keyLength))
		}
		os.Exit(1)
	}
	DB, _ = scribble.New(Cfg.Bucket, nil)
	commonIV = []byte{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f}
	c, err = aes.NewCipher([]byte(Cfg.Key))
	if err != nil {
		fmt.Printf("Error: NewCipher(%d bytes) = %s", len(Cfg.Key), err)
		os.Exit(-1)
	}
}

func createPag() (pag string) {
	pages := (countArticles() / Cfg.NumerOfArticles) + 1
	fmt.Println("Pages", pages, "Count", countArticles(), "CFG", Cfg.NumerOfArticles)
	pag = pag + "<ul id='pagination'>"
	pag = fmt.Sprintf("%s<li><a href='%s'>Page 1</a></li>", pag, baseURL(""))
	var offset = 1
	for i := 2; i < pages+1; i++ {
		off := Cfg.NumerOfArticles * offset
		pag = fmt.Sprintf("%s<li><a href='%s'>Page %d</a></li>", pag, baseURL(fmt.Sprintf("?o=%d", off)), i)
		offset++
	}
	pag = pag + "</ul>"
	return
}

func main() {
	r := mux.NewRouter()
	r.HandleFunc("/", indexHandler)
	r.HandleFunc("/list", listAllHandler).Methods("GET")
	r.HandleFunc("/create", createHandler).Methods("GET")
	r.HandleFunc("/create", createPostHandler).Methods("POST")
	r.HandleFunc("/article/{link}", viewHandler).Methods("GET")
	r.HandleFunc("/delete/{link}", deleteHandler).Methods("GET")
	r.HandleFunc("/edit/{link}", editHandler).Methods("GET")
	r.HandleFunc("/edit/{link}", editPostHandler).Methods("POST")
	r.HandleFunc("/search", searchHandler).Methods("GET")
	r.HandleFunc("/search", searchPostHandler).Methods("POST")
	r.HandleFunc("/l", loginHandler).Methods("GET")
	r.HandleFunc("/l", loginPostHandler).Methods("POST")
	r.HandleFunc("/lo", logoutHandler).Methods("GET")

	http.Handle("/", r)
	fmt.Printf("Running %s on %s:%s", GOW_TITLE, Cfg.Host, Cfg.Port)
	err := http.ListenAndServe(fmt.Sprintf("%s:%s", Cfg.Host, Cfg.Port), nil)
	if err != nil {
		log.Fatal("ListenAndServe: ", err)
	}
}

func appendHeader(ili bool) string {
	if ili {
		return fmt.Sprintf(GOW_HEADER, `
			<li>
				<div class="go-back-link">
					<a href="/create">Create new article</a>
				</div>
			</li>
			<li>
				<div class="go-back-link">
					<a href="/lo">Logout</a>
				</div>
			</li>`)
	}
	return fmt.Sprintf(GOW_HEADER, "")
}

func trimFooter(ili bool) string {
	return GOW_FOOTER
}

func getNumAndOff(r *http.Request) (n int, o int) {
	var (
		gnum = 0
		goff = 0
		err  error
	)
	givenNumber := r.URL.Query().Get("n")
	if len(givenNumber) > 0 {
		gnum, err = strconv.Atoi(givenNumber)
		if err != nil {
			log.Println("error", err)
		}
	}
	givenOffset := r.URL.Query().Get("o")
	if len(givenOffset) > 0 {
		goff, err = strconv.Atoi(givenOffset)
		if err != nil {
			log.Println("error", err)
		}
	}
	n = Cfg.NumerOfArticles
	o = 0
	if gnum > 0 {
		n = gnum
	}
	if goff > 0 {
		o = goff
	}
	return
}

func indexHandler(w http.ResponseWriter, r *http.Request) {
	articles := getArticles(getNumAndOff(r))
	var articleContent string
	if len(articles) > 0 {
		for _, v := range articles {

			cfbdec := cipher.NewCFBDecrypter(c, commonIV)
			plaintextCopy := make([]byte, v.PTL)
			cfbdec.XORKeyStream(plaintextCopy, v.Content)
			unsafe := blackfriday.MarkdownCommon(plaintextCopy)
			html := bluemonday.UGCPolicy().SanitizeBytes(unsafe)
			cString, err := sanitize.HTMLAllowing(string(html), []string{"p"})
			if err != nil {
				log.Println("error", err)
			}
			stringHtml := cString
			if len(stringHtml) > 200 {
				stringHtml = stringHtml[0:200] + "..."
			}
			articleContent = articleContent + fmt.Sprintf("<article><h2><a href='%s'>%s</a></h2><div><small>%s</small></div><div>%s</div></article>", baseURL(fmt.Sprintf("article/%s", v.Link)), v.Title, v.Created, stringHtml)
		}
	} else {
		articleContent = "<h2 class='big'>No content found</h2>"
	}
	t := template.New("indexTpl")
	MyHtml := appendHeader(isLoggedIn(w, r))
	MyHtml = MyHtml + articleContent
	if countArticles() > Cfg.NumerOfArticles {
		MyHtml = MyHtml + fmt.Sprintf("%s%s", createPag(), GOW_FOOTER)
	} else {
		MyHtml = MyHtml + GOW_FOOTER
	}

	t, _ = t.Parse(MyHtml)
	t.Execute(w, nil)
}

func isLoggedIn(w http.ResponseWriter, r *http.Request) bool {
	session, err := store.Get(r, "gow")
	if err != nil {
		log.Println(err.Error())
		return false
	}
	val := session.Values["gowili"]
	if val == gowUUID {
		return true
	}
	return false
}

func baseURL(path string) (URL string) {
	var (
		scheme     string
		ignorePort bool
	)
	switch Cfg.Port {
	case "443":
		scheme = "https"
		ignorePort = true
		break
	case "80":
		scheme = "http"
		ignorePort = true
	default:
		scheme = "http"
		break
	}
	URL = fmt.Sprintf("%s://%s", scheme, Cfg.Host)
	if !ignorePort {
		URL = fmt.Sprintf("%s:%s", URL, Cfg.Port)
	}
	URL = fmt.Sprintf("%s/", URL)
	if len(path) > 0 {
		URL = fmt.Sprintf("%s%s", URL, path)
	}
	return
}

func deleteHandler(w http.ResponseWriter, r *http.Request) {
	if !isLoggedIn(w, r) {
		http.Redirect(w, r, baseURL("l"), http.StatusSeeOther)
		return
	}
	vars := mux.Vars(r)
	link := vars["link"]
	confirmGet := r.URL.Query().Get("confirmed")
	if confirmGet == "yes" {
		if err := DB.Delete("articles", link); err != nil {
			fmt.Println("Error", err)
		}
		http.Redirect(w, r, "/", http.StatusMovedPermanently)
	} else {
		t := template.New("deleteTpl")
		MyHtml := appendHeader(isLoggedIn(w, r)) + `
		<h3>Are you sure?</h3>
		<p>
			Deleting an article is permanent and cannot be undone.
		</p>
		<p>
			<a href="/article/` + link + `">Abort</a> <a style="margin-left: 50px;" href="/delete/` + link + `?confirmed=yes">Proceed</a>
		</p>
	` + trimFooter(isLoggedIn(w, r))
		t, _ = t.Parse(MyHtml)
		t.Execute(w, nil)
	}
}

func viewHandler(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	link := vars["link"]
	article := getByLink(link)
	headers := getAllHeaders()
	t := template.New("viewTpl")
	cfbdec := cipher.NewCFBDecrypter(c, commonIV)
	plaintextCopy := make([]byte, article.PTL)
	cfbdec.XORKeyStream(plaintextCopy, article.Content)
	unsafe := blackfriday.MarkdownCommon(plaintextCopy)
	html := bluemonday.UGCPolicy().SanitizeBytes(unsafe)
	stringHtml := string(html)
	for _, v := range headers {
		if v.Link != link {
			stringHtml = strings.Replace(stringHtml, v.Title, fmt.Sprintf("<a href='/article/%s'>%s</a>", v.Link, v.Title), -1)
		}
	}
	MyHtml := appendHeader(isLoggedIn(w, r))
	if isLoggedIn(w, r) {
		MyHtml = MyHtml + "<div class='go-back-link'><a href='/edit/" + article.Link + "'>Edit article</a><a href='/delete/" + article.Link + "'>Delete article</a></div>"
	}
	MyHtml = MyHtml + `
			<h1>
				` + article.Title + `
			</h1>
			<small><em>Added/Updated ` + article.Created + `</em></small>
			` + stringHtml + `
		` + trimFooter(isLoggedIn(w, r))
	t, _ = t.Parse(MyHtml)
	t.Execute(w, nil)
}

func getByLink(link string) (art article) {
	cacheObj, found := Cache.Get(link)
	if !found {
		if err := DB.Read("articles", link, &art); err != nil {
			log.Println("Error", err)
		}
		Cache.Set(link, art, cache.DefaultExpiration)
	} else {
		raw := cacheObj.(article)
		art.Content = raw.Content
		art.Created = raw.Created
		art.Link = raw.Link
		art.PTL = raw.PTL
		art.Title = raw.Title
	}
	return
}

func listAllHandler(w http.ResponseWriter, r *http.Request) {
	var (
		tplArticles []string
		articles    []article
	)
	records, _ := DB.ReadAll("articles")
	for _, v := range records {
		article := article{}
		if err := json.Unmarshal([]byte(v), &article); err != nil {
			fmt.Println("Error", err)
		}
		articles = append(articles, article)
	}
	sort.Sort(articlesDescending(articles))
	for _, article := range articles {
		tplArticles = append(tplArticles, fmt.Sprintf("<li><a href='/article/%s'>%s</a></li>", article.Link, article.Title))
	}
	joinedArticlesList := strings.Join(tplArticles, "")
	t := template.New("listAllTpl")
	MyHtml := appendHeader(isLoggedIn(w, r)) + `
	 	<ul>
	 		` + joinedArticlesList + `
	 	</ul>
	 ` + trimFooter(isLoggedIn(w, r))
	t, _ = t.Parse(MyHtml)
	t.Execute(w, nil)
}

func createPostHandler(w http.ResponseWriter, r *http.Request) {
	if !isLoggedIn(w, r) {
		http.Redirect(w, r, baseURL("l"), http.StatusSeeOther)
		return
	}
	title := base64.StdEncoding.EncodeToString([]byte(r.FormValue("title")))
	cfb := cipher.NewCFBEncrypter(c, commonIV)
	ciphertext := make([]byte, len(r.FormValue("content")))
	cfb.XORKeyStream(ciphertext, []byte(r.FormValue("content")))
	article := article{
		Link:    title,
		Title:   r.FormValue("title"),
		Content: ciphertext,
		Created: time.Now().String(),
		PTL:     len(r.FormValue("content")),
	}
	if err := DB.Write("articles", title, article); err != nil {
		fmt.Println("Error", err)
	}
	http.Redirect(w, r, baseURL(fmt.Sprintf("article/%s", article.Link)), http.StatusMovedPermanently)
}

func getCurrURL(r *http.Request) (cURL string) {
	h := r.Host
	t := r.URL.String()
	var (
		scheme string
	)
	switch Cfg.Port {
	case "443":
		scheme = "https"
		break
	case "80":
		scheme = "http"
	default:
		scheme = "http"
		break
	}
	cURL = fmt.Sprintf("%s://%s%s", scheme, h, t)
	return
}

func createHandler(w http.ResponseWriter, r *http.Request) {
	if !isLoggedIn(w, r) {
		http.Redirect(w, r, baseURL("l"), http.StatusSeeOther)
		return
	}
	var presetTitle string
	sentTitle := r.URL.Query().Get("t")
	if sentTitle != "" && len(sentTitle) > 2 {
		presetTitle = sentTitle
	}
	t := template.New("createTpl")
	MyHtml := appendHeader(isLoggedIn(w, r))

	if presetTitle != "" && len(presetTitle) > 2 {
		referer := r.Referer()
		currURL := getCurrURL(r)
		if referer != currURL {
			MyHtml = MyHtml + `<div class="go-back-link">
			<a href="` + referer + `">Go back</a>
		</div>`
		}
	}

	MyHtml = MyHtml + `
	  <form name="create" method="POST" action="">
  		<p>
			<input type="text" name="title" style="width:90%;padding:5px;" value="` + presetTitle + `" placeholder="Title..." pattern="[a-zA-Z0-9åäöÅÄÖ,_.-/\:+?! ]{2,250}" />
		</p>
		<p>
			<textarea name="content" placeholder="Article content..." style="width:90%; height:350px; padding:5px;"></textarea>
		</p>
		<p>
			<button type="submit" name="submit" style="background:#53DF83;padding:6px 12px;border:0;">Save</button>
		</p>
	  </form>
	  ` + trimFooter(isLoggedIn(w, r))
	t, _ = t.Parse(MyHtml)
	t.Execute(w, nil)
}

func editHandler(w http.ResponseWriter, r *http.Request) {
	if !isLoggedIn(w, r) {
		http.Redirect(w, r, baseURL("l"), http.StatusSeeOther)
		return
	}
	vars := mux.Vars(r)
	link := vars["link"]
	article := article{}
	if err := DB.Read("articles", link, &article); err != nil {
		fmt.Println("Error", err)
	}
	t := template.New("editTpl")
	cfbdec := cipher.NewCFBDecrypter(c, commonIV)
	plaintextCopy := make([]byte, article.PTL)
	cfbdec.XORKeyStream(plaintextCopy, article.Content)
	stringHtml := string(plaintextCopy)

	MyHtml := appendHeader(isLoggedIn(w, r))

	MyHtml = MyHtml + `<div class="go-back-link">
			<a href="/article/` + link + `">Abort</a>
		</div>
	  <form name="edit" method="POST" action="">
  		<p>
			<input type="text" name="title" style="width:90%;padding:5px;" value="` + article.Title + `" placeholder="Title..." pattern="[a-zA-Z0-9åäöÅÄÖ,_.-/\:+?! ]{2,250}" />
		</p>
		<p>
			<textarea name="content" placeholder="Article content..." style="width:90%; height:350px; padding:5px;">` + stringHtml + `</textarea>
		</p>
		<p>
			<button type="submit" name="submit" style="background:#53DF83;padding:6px 12px;border:0;">Save</button>
		</p>
	  </form>
	  ` + trimFooter(isLoggedIn(w, r))
	t, _ = t.Parse(MyHtml)
	t.Execute(w, nil)
}

func loginHandler(w http.ResponseWriter, r *http.Request) {
	if isLoggedIn(w, r) == true {
		http.Redirect(w, r, baseURL("create"), http.StatusSeeOther)
	}
	if isLoggedIn(w, r) != true {
		t := template.New("indexTpl")
		MyHtml := appendHeader(isLoggedIn(w, r))
		MyHtml = MyHtml + `
		<h1>Login to ` + GOW_TITLE + `</h1>
		<form method="post" action="/l">
		<input type="text" name="user" /><br />
		<input type="password" name="pwd" /><br />
		<input type="submit" name="submit" value="Login" />
		</form>
	`
		MyHtml = MyHtml + trimFooter(isLoggedIn(w, r))
		t, _ = t.Parse(MyHtml)
		t.Execute(w, nil)
	}
}

func loginPostHandler(w http.ResponseWriter, r *http.Request) {
	givenUser := r.PostFormValue("user")
	givenPwd := r.PostFormValue("pwd")
	if givenUser == Cfg.User && givenPwd == Cfg.Pwd {
		session, err := store.Get(r, "gow")
		if err != nil {
			log.Println(err.Error())
			return
		}
		session.Values["gowili"] = gowUUID
		session.Save(r, w)
		http.Redirect(w, r, baseURL("create"), http.StatusSeeOther)
	}
}

func logoutHandler(w http.ResponseWriter, r *http.Request) {
	session, err := store.Get(r, "gow")
	if err != nil {
		log.Println(err.Error())
		return
	}
	session.Values["gowili"] = ""
	session.Save(r, w)
	http.Redirect(w, r, baseURL("l"), http.StatusSeeOther)
}

func editPostHandler(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	link := vars["link"]
	title := base64.StdEncoding.EncodeToString([]byte(r.FormValue("title")))

	if link != title {
		if err := DB.Delete("articles", link); err != nil {
			fmt.Println("Error", err)
		}
		link = title
	}

	cfb := cipher.NewCFBEncrypter(c, commonIV)
	ciphertext := make([]byte, len(r.FormValue("content")))
	cfb.XORKeyStream(ciphertext, []byte(r.FormValue("content")))
	article := article{
		Link:    link,
		Title:   r.FormValue("title"),
		Content: ciphertext,
		Created: time.Now().String(),
		PTL:     len(r.FormValue("content")),
	}
	if err := DB.Write("articles", title, article); err != nil {
		fmt.Println("Error", err)
	}
	Cache.Delete(link)
	http.Redirect(w, r, fmt.Sprintf("/article/%s", article.Link), http.StatusMovedPermanently)
}

func searchHandler(w http.ResponseWriter, r *http.Request) {
	t := template.New("searchTpl")
	MyHtml := appendHeader(isLoggedIn(w, r))
	MyHtml = MyHtml + `
	  <form name="search" method="POST" action="">
  		<p>
			<input type="text" name="search_term" style="width:80%;padding:5px;" placeholder="What are you looking for?" pattern="[a-zA-Z0-9åäöÅÄÖ,_.-/\:+?! ]{2,250}" />
			<button type="submit" name="submit" style="background:#53DF83;padding:6px 12px;border:0;">Search</button>
		</p>
	  </form>
	  ` + trimFooter(isLoggedIn(w, r))
	t, _ = t.Parse(MyHtml)
	t.Execute(w, nil)
}

func searchPostHandler(w http.ResponseWriter, r *http.Request) {
	searchTerm := r.FormValue("search_term")
	headers := getAllHeaders()
	var headerTitles []string
	for _, v := range headers {
		headerTitles = append(headerTitles, v.Title)
	}
	matches := fuzzy.RankFindFold(searchTerm, headerTitles)
	t := template.New("searchTpl")
	MyHtml := appendHeader(isLoggedIn(w, r))
	MyHtml = MyHtml + `
	  <form name="search" method="POST" action="">
  		<p>
			<input type="text" name="search_term" style="width:80%;padding:5px;" placeholder="What are you looking for?" pattern="[a-zA-Z0-9åäöÅÄÖ,_.-/\:+?! ]{2,250}" />
			<button type="submit" name="submit" style="background:#53DF83;padding:6px 12px;border:0;">Search</button>
		</p>
	  </form>
	  <hr />
	  `
	var articleList []string
	counter := 1
	for _, v := range matches {
		article := getByLink(base64.StdEncoding.EncodeToString([]byte(v.Target)))
		articleList = append(articleList, `<div class="article-item">
			<h5>#`+fmt.Sprintf("%d", counter)+`. <a href="/article/`+article.Link+`">`+article.Title+`</a></h5>
		</div>`)
		counter++
	}
	MyHtml = MyHtml + strings.Join(articleList, "")
	MyHtml = MyHtml + trimFooter(isLoggedIn(w, r))
	t, _ = t.Parse(MyHtml)
	t.Execute(w, nil)
}

func getAllHeaders() (articles []article) {
	records, err := DB.ReadAll("articles")
	if err != nil {
		fmt.Println("Error", err)
	}
	for _, v := range records {
		article := article{}
		if err := json.Unmarshal([]byte(v), &article); err != nil {
			fmt.Println("Error", err)
		}
		articles = append(articles, article)
	}
	return
}

func countArticles() int {
	records, err := DB.ReadAll("articles")
	if err != nil {
		fmt.Println("Error", err)
	}
	return len(records)
}

func getArticles(number int, offset int) (articles []article) {
	allArticles := getAllHeaders()
	sort.Sort(articlesDateDescending(allArticles))
	o := 0
	c := 0
Loop:
	for _, v := range allArticles {
		if c >= number {
			break Loop
		}
		if o < offset {
			log.Println(o, "is less than", offset)
			o++
			continue
		}
		articles = append(articles, v)
		c++
		o++
	}
	return
}
